// Battlecode 2017 - Unified Build
// This build file compiles the game engine, players, and can run matches

buildscript {
    ext.versions = [
        kotlin: '1.0.6',
        scala: '2.11.7'
    ]

    repositories {
        mavenLocal()
        mavenCentral()
    }
    dependencies {
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$versions.kotlin"
    }
}

apply plugin: 'java'
apply plugin: 'kotlin'
apply plugin: 'scala'
apply plugin: 'idea'
apply plugin: 'eclipse'

sourceCompatibility = 1.8
targetCompatibility = 1.8

// Engine source set (the game server)
sourceSets {
    engine {
        java.srcDirs = ["engine"]
        resources.srcDirs = ["engine"]
        output.classesDir = "$buildDir/engine-classes"
        output.resourcesDir = "$buildDir/engine-classes"
    }

    // Player source set
    main {
        java.srcDirs = ["src"]
        scala.srcDirs = ["src"]
        kotlin.srcDirs = ["src"]
        output.classesDir = "$buildDir/classes"
    }

    test {
        java.srcDirs = ["test"]
        scala.srcDirs = ["test"]
        kotlin.srcDirs = ["test"]
        output.classesDir = "$buildDir/tests"
    }
}

repositories {
    mavenLocal()
    mavenCentral()
}

dependencies {
    // Engine dependencies
    engineCompile (
        [group: 'org.slf4j', name: 'slf4j-api', version: '1.7.21'],
        [group: 'org.slf4j', name: 'slf4j-simple', version: '1.7.21'],
        [group: 'org.apache.commons', name: 'commons-lang3', version: '3.4'],
        [group: 'commons-cli', name: 'commons-cli', version: '1.3.1'],
        [group: 'commons-io', name: 'commons-io', version: '2.4'],
        [group: 'org.ow2.asm', name: 'asm', version: '5.0.4'],
        [group: 'org.ow2.asm', name: 'asm-tree', version: '5.0.4'],
        [group: 'com.github.davidmoten', name: 'flatbuffers-java', version: '1.4.0.1'],
        [group: 'org.java-websocket', name: 'Java-WebSocket', version: '1.3.0'],
        [group: 'org.hibernate', name: 'hibernate-search', version: '3.1.0.GA'],
        [group: 'net.sf.jsi', name: 'jsi', version: '1.1.0-SNAPSHOT'],
        [group: 'net.sf.trove4j', name: 'trove4j', version: '3.0.3'],
        [group: 'org.jetbrains.kotlin', name: 'kotlin-stdlib', version: versions.kotlin]
    )

    // Javadoc manipulation (for engine)
    engineCompile files(System.getenv('JAVA_HOME') + '/lib/tools.jar')

    // Player dependencies - depend on the engine
    compile sourceSets.engine.output
    compile sourceSets.engine.compileClasspath
    compile "org.jetbrains.kotlin:kotlin-stdlib:$versions.kotlin"
    compile group: 'org.scala-lang', name: 'scala-library', version: versions.scala
    compile group: 'org.scala-lang', name: 'scala-compiler', version: versions.scala
    compile group: 'org.scala-lang', name: 'scala-reflect', version: versions.scala

    // Test dependencies
    testCompile sourceSets.main.output
    testCompile 'junit:junit:4.12'
}

// Build the engine first
compileJava.dependsOn compileEngineJava
compileKotlin.dependsOn compileEngineKotlin

// Default configuration for running matches
if (!project.hasProperty("teamA")) {
    ext.teamA = "examplefuncsplayer"
}
if (!project.hasProperty("teamB")) {
    ext.teamB = "examplefuncsplayer"
}
if (!project.hasProperty("maps")) {
    ext.maps = "Shrine"
}

// Task to run a headless match
task run(type: JavaExec, dependsOn: 'build') {
    description 'Runs a match without starting the client.'
    group 'battlecode'

    main = 'battlecode.server.Main'
    classpath = sourceSets.main.runtimeClasspath + sourceSets.engine.runtimeClasspath
    args = ['-c=-']
    jvmArgs = [
        '-Dbc.server.mode=headless',
        '-Dbc.server.map-path=maps',
        '-Dbc.server.debug=false',
        '-Dbc.engine.debug-methods=false',
        '-Dbc.server.robot-player-to-system-out=false',
        '-Dbc.game.team-a='+project.property('teamA'),
        '-Dbc.game.team-b='+project.property('teamB'),
        '-Dbc.game.team-a.url='+sourceSets.main.output.classesDir,
        '-Dbc.game.team-b.url='+sourceSets.main.output.classesDir,
        '-Dbc.game.maps='+project.property('maps'),
        '-Dbc.server.wait-for-client=' + (project.hasProperty('waitForClient') ? project.waitForClient : 'false'),
        '-Dbc.server.save-file=' + 'matches/' + project.property('teamA') + '-vs-' + project.property('teamB') + '-on-' + project.property('maps') + '.bc17'
    ]
}

// Task to run match with debug support
task runDebug(type: JavaExec, dependsOn: 'build') {
    description 'Runs a match with debug support on port 5005.'
    group 'battlecode'

    main = 'battlecode.server.Main'
    classpath = sourceSets.main.runtimeClasspath + sourceSets.engine.runtimeClasspath
    args = ['-c=-']
    jvmArgs = [
        '-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005',
        '-Dbc.server.mode=headless',
        '-Dbc.server.map-path=maps',
        '-Dbc.server.debug=true',
        '-Dbc.engine.debug-methods=true',
        '-Dbc.game.team-a='+project.property('teamA'),
        '-Dbc.game.team-b='+project.property('teamB'),
        '-Dbc.game.team-a.url='+sourceSets.main.output.classesDir,
        '-Dbc.game.team-b.url='+sourceSets.main.output.classesDir,
        '-Dbc.game.maps='+project.property('maps'),
        '-Dbc.server.save-file=' + 'matches/' + project.property('teamA') + '-vs-' + project.property('teamB') + '-on-' + project.property('maps') + '.bc17'
    ]
}

// List all available players
task listPlayers {
    description 'Lists all available players.'
    group 'battlecode'

    doLast {
        sourceSets.main.allSource.each {
            if (it.getName().equals('RobotPlayer.java')
                || it.getName().equals('RobotPlayer.kt')
                || it.getName().equals('RobotPlayer.scala')) {
                URI base = new File(project.projectDir, 'src').toURI()
                URI full = it.toURI()
                String path = base.relativize(full).toString()
                println 'PLAYER: '+path.substring(0, path.lastIndexOf('/')).replaceAll('/', '.')
            }
        }
    }
}

// List all available maps
task listMaps {
    description 'Lists all available maps.'
    group 'battlecode'

    doLast {
        sourceSets.engine.runtimeClasspath.each {
            if (it.isDirectory()) {
                fileTree(it).each { f ->
                    if (f.getName().endsWith('.map17')) {
                        println 'MAP: '+f.getName().replace('.map17', '')
                    }
                }
            } else if (it.getName().endsWith('.jar')) {
                zipTree(it).each { f ->
                    if (f.getName().endsWith('.map17')) {
                        println 'MAP: '+f.getName().replace('.map17', '')
                    }
                }
            }
        }
        // Also check local maps folder
        fileTree('maps').each { f ->
            if (f.getName().endsWith('.map17')) {
                println 'MAP: '+f.getName().replace('.map17', '')
            }
        }
    }
}

// Client tasks
task clientInstall(type: Exec) {
    description 'Installs client dependencies (npm install).'
    group 'battlecode'
    workingDir 'client'
    commandLine 'npm', 'install'
}

task clientBuild(type: Exec, dependsOn: 'clientInstall') {
    description 'Builds the client.'
    group 'battlecode'
    workingDir 'client'
    commandLine 'npm', 'run', 'build'
}

task clientWatch(type: Exec) {
    description 'Starts the client dev server at http://localhost:8080'
    group 'battlecode'
    workingDir 'client'
    commandLine 'npm', 'run', 'watch'
}

// Prepare upload jar
task jarForUpload(type: Jar) {
    description 'Assembles source code into an archive for upload to battlecode.org'
    group 'battlecode'

    from sourceSets.main.allSource
    destinationDir = project.projectDir
    archiveName = 'battlecode-player-upload.jar'
}

// Eclipse settings
eclipse {
    classpath {
        downloadJavadoc = true
        downloadSources = true
        defaultOutputDir = new File(project.buildDir, 'classes-eclipse')
    }
}

// IntelliJ settings
idea {
    module {
        downloadSources = true
        downloadJavadoc = true
    }
}

build.group = 'battlecode'

// Match summary generation
// Creates summaries/ directory if it doesn't exist
task createSummariesDir {
    doLast {
        file('summaries').mkdirs()
    }
}

// Generate summary for a specific match file
task summarize(type: Exec, dependsOn: 'createSummariesDir') {
    description 'Generates an LLM-friendly summary of a match file.'
    group 'battlecode'

    def matchFile = project.hasProperty('matchFile') ? project.property('matchFile') : null
    def outputFile = project.hasProperty('outputFile') ? project.property('outputFile') : null

    doFirst {
        if (!matchFile) {
            throw new GradleException('Please specify -PmatchFile=path/to/match.bc17')
        }

        def timestamp = new Date().format('yyyyMMdd_HHmmss')
        def baseName = new File(matchFile).name.replace('.bc17', '')
        def summaryFile = outputFile ?: "summaries/summary_${baseName}_${timestamp}.md"

        commandLine 'python3', 'scripts/bc17_summary.py', matchFile, summaryFile
    }

    // Fallback if doFirst doesn't set commandLine properly
    commandLine 'python3', '--version'
}

// Combined task: run match and generate summary
task runWithSummary(dependsOn: 'createSummariesDir') {
    description 'Runs a match and generates an LLM-friendly summary.'
    group 'battlecode'

    doLast {
        // NOTE: Summaries are NOT deleted here - bc-manager handles cleanup
        // after reading all 5 map summaries for comprehensive analysis

        // Build the match file path
        def matchFile = 'matches/' + project.property('teamA') + '-vs-' + project.property('teamB') + '-on-' + project.property('maps') + '.bc17'
        def timestamp = new Date().format('yyyyMMdd_HHmmss')
        def baseName = project.property('teamA') + '-vs-' + project.property('teamB') + '-on-' + project.property('maps')
        def summaryFile = "summaries/summary_${baseName}_${timestamp}.md"

        // Run the match
        javaexec {
            main = 'battlecode.server.Main'
            classpath = sourceSets.main.runtimeClasspath + sourceSets.engine.runtimeClasspath
            args = ['-c=-']
            jvmArgs = [
                '-Dbc.server.mode=headless',
                '-Dbc.server.map-path=maps',
                '-Dbc.server.debug=false',
                '-Dbc.engine.debug-methods=false',
                '-Dbc.server.robot-player-to-system-out=false',
                '-Dbc.game.team-a='+project.property('teamA'),
                '-Dbc.game.team-b='+project.property('teamB'),
                '-Dbc.game.team-a.url='+sourceSets.main.output.classesDir,
                '-Dbc.game.team-b.url='+sourceSets.main.output.classesDir,
                '-Dbc.game.maps='+project.property('maps'),
                '-Dbc.server.wait-for-client=false',
                '-Dbc.server.save-file=' + matchFile
            ]
        }

        // Generate summary
        exec {
            commandLine 'python3', 'scripts/bc17_summary.py', matchFile, summaryFile
        }

        println "\n=========================================="
        println "Match complete!"
        println "Replay file: ${matchFile}"
        println "Summary file: ${summaryFile}"
        println "==========================================\n"
    }
}
runWithSummary.dependsOn build

// Map info extraction task
task mapInfo(type: JavaExec, dependsOn: 'compileEngineJava') {
    description 'Prints detailed information about a map.'
    group 'battlecode'

    main = 'battlecode.util.MapInfoPrinter'
    classpath = sourceSets.engine.runtimeClasspath

    doFirst {
        if (!project.hasProperty('map')) {
            throw new GradleException('Please specify -Pmap=MapName')
        }
        args = [project.property('map')]
    }
}

// Map tree cleaning task
task cleanMapTrees(type: JavaExec, dependsOn: 'compileEngineJava') {
    description 'Removes overlapping trees from a map to improve performance.'
    group 'battlecode'

    main = 'battlecode.util.MapTreeCleaner'
    classpath = sourceSets.engine.runtimeClasspath

    doFirst {
        if (!project.hasProperty('map')) {
            throw new GradleException('Please specify -Pmap=MapName')
        }
        args = project.hasProperty('output') ? [project.property('map'), project.property('output')] : [project.property('map')]
    }
}

// Map tree regeneration task
task regenerateMapTrees(type: JavaExec, dependsOn: 'compileEngineJava') {
    description 'Regenerates map with symmetrical, neatly spaced trees.'
    group 'battlecode'

    main = 'battlecode.util.MapTreeRegenerator'
    classpath = sourceSets.engine.runtimeClasspath

    doFirst {
        if (!project.hasProperty('map')) {
            throw new GradleException('Please specify -Pmap=MapName')
        }
        args = project.hasProperty('output') ? [project.property('map'), project.property('output')] : [project.property('map')]
    }
}

// Map tree dumper task
task dumpMapTrees(type: JavaExec, dependsOn: 'compileEngineJava') {
    description 'Dumps all tree positions and checks symmetry.'
    group 'battlecode'

    main = 'battlecode.util.MapTreeDumper'
    classpath = sourceSets.engine.runtimeClasspath

    doFirst {
        if (!project.hasProperty('map')) {
            throw new GradleException('Please specify -Pmap=MapName')
        }
        args = [project.property('map')]
    }
}

// Map visualizer task
task visualizeMap(type: JavaExec, dependsOn: 'compileEngineJava') {
    description 'Visualizes map as ASCII grid.'
    group 'battlecode'

    main = 'battlecode.util.MapVisualizer'
    classpath = sourceSets.engine.runtimeClasspath

    doFirst {
        if (!project.hasProperty('map')) {
            throw new GradleException('Please specify -Pmap=MapName')
        }
        args = [project.property('map')]
    }
}

// Generate summaries for all existing match files
task summarizeAll(dependsOn: 'createSummariesDir') {
    description 'Generates summaries for all match files in matches/ directory.'
    group 'battlecode'

    doLast {
        def timestamp = new Date().format('yyyyMMdd_HHmmss')
        fileTree('matches').each { matchFile ->
            if (matchFile.name.endsWith('.bc17')) {
                def baseName = matchFile.name.replace('.bc17', '')
                def summaryFile = "summaries/summary_${baseName}_${timestamp}.md"

                exec {
                    commandLine 'python3', 'scripts/bc17_summary.py', matchFile.absolutePath, summaryFile
                }
                println "Generated: ${summaryFile}"
            }
        }
    }
}
